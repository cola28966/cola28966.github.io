{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"多线程","link":"/tags/index.html"}],"posts":[{"title":"Java类加载机制","text":"什么是类加载机制Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制。 类加载机制的生命周期类加载机制的生命周期分为加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备和解析统称为连接 加载阶段：就是类的数据从 Class 文件加载到内存的过程 加载所需要完成的三件事情： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构 在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问路口 加载阶段和连接阶段的部分动作是交叉进行的 验证阶段：确保 Class 文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身安全。包括文件格式验证、元数据验证、字节码验证以及符号引用验证 准备阶段：为类中静态变量分配内存并设置初始值，通常情况为数据的零值，若为 final 类型则不变 解析阶段：Java 虚拟机将常量池内符合引用替换为直接引用的过程。符合引用以一组符合来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可解析可能在初始化之后 初始化阶段：为类的静态变量赋予正确的初始值 什么是类加载器实现 “通过一个类的全限定名来获取描述该类的二进制字节流” 的动作的代码称为 “类加载器” （Class Loader） 类和类加载器对于任意的一个类，都必须由加载它的类加载器和这个类本身一起共同确定其在Java虚拟机中的唯一确定性，每 一个类加载器，都拥有独立的类名称空间 类加载器的分类从Java虚拟机角度 启动类加载器（Bootstrap ClassLoader）： 这个类加载器使用 C++ 语言实现，是虚拟机的一部分 其他所有类加载器： 这些类加载器都由 Java 语言实现，独立存在于虚拟机外部，并且全部继承自抽象类 java.lang.ClassLoader 从Java开发人员角度 启动类加载器（Bootstrap ClassLoader）： 启动类加载器负责加载存放在 JDK\\jre\\lib 下，或被-Xbootclasspath参数指定的路径的类 扩展类加载器（Extension ClassLoader）： 扩展类加载器负责加载 JDK\\jre\\lib\\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如 javax.* 开头的类） 应用类加载器（Application ClassLoader）： 应用类加载器负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。 双亲委派模型 双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都是传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围内没有找到所需要的类）时，子加载器才会自己去完成加载 双亲委派模型的好处：Java中类随着它的类加载器一起具备了一种带有优先级的层次关系 例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。 参考资料 深入理解Java虚拟机，周志明著，机械工业出版社，2020年","link":"/2020/05/03/ava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"title":"Java多线程(三）","text":"一 Java多线程信息共享1 实现信息共享的方式通过共享变量在多个线程中共享消息 static变量，对应继承Thread类的线程只能通过这种方式 同一个Runnable类的成员变量 2 多线程信息共享问题Java内存模型中的内存结构Java内存模型将内存分为共享内存和本地内存。共享内存又称为堆内存，指的就是线程之间共享的内存，包含所有的实列域、静态域和数组元素。每一个线程都有一个私有的，只对自己可见的内存，称之为本地内存。线程并不直接使用共享内存，而是会在本地内存中存储一个共享内存的副本，使用这个副本参与运算。由于这个副本的参与，导致了线程之间对共享内存的读写存在可见性问题。 可见性 可见性是指，当一个线程对共享变量进行了修改，那么其他线程可以立刻看到修改后的最新值。Java多线程环境下，线程首次读取要操作的变量时，是先到主内存中获取该变量，然后将其放入工作内存，以后关于该变量的操作都是在以工作内存中的变量值为基准的。之后如果要修改该变量的值，也是直接修改工作内存中的变量，最后会在某一时刻将工作内存中该变量的值刷新同步回主内存，之后其他线程就能感知到该变量的变化，实现可见性了！ 只是什么时候将工作内存中的值同步会主内存，这个时间点在自然情况下是不确定的，所以假设线程A修改了变量的值之后，在正式将其同步会主内存之前，线程B获取了主内存中变量的原先值，而过了一会后线程A刷新了主内存，但是此时主内存中的变量值与线程B工作内存中的变量值已经不一致了，这个时候就出现不可见的问题了。volatile来声明变量或者用锁来保护起来 原子性 所谓原子性是指在一个操作或多次操作中，要么所有的操作全部都得到执行，要么所有的操作都不执行。 i++，并非原子性操作 1 主存i到工作缓存(副本)中 2 个CPU执行副本i+1操作 3 CPU将结果写入副本中 4 数据从副本刷到主存中 volatile Java语言提供了一种稍弱的同步机制，即volatile类型，用来确保将变量的更新操作通知到其他线程。使用就是在变量前面加上volatile即可。在 JMM 中，线程之间的通信采用共享内存来实现的。volatile 的内存语义是： 当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值，立即刷新到主内存中。 当读一个 volatile 变量时，JMM 会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量。 对于volatile只能保证可见性不能确保原子性对于++i说当线程A执行完第二步，此时线程B更改了变量i的值，虽然此时线程A知道变量i发生了变化，但是由于操作已经执行完，所以还是只能执行第3步把变量i的值覆盖回主内存，从而又造成了错误数据。 synchronized 对于保证原子性操作可以使用synchronized来实现某一个线程运行一个代码块，其他线程不能运行这个代码块","link":"/2020/02/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89%EF%BC%89/"},{"title":"Java多线程(一)","text":"一 进程和线程的定义和区别进程： 每个独立执行的任务就是一个进程线程：一个程序可以包括多个子任务，可窜/并行，每个子任务可以称为一个线程，线程是进程的一部分。 多线程vs多进程 线程数据共享 线程通讯更高效 线程更清量级，更容易切换 多个线程更容易管理 二 多线程的创建Java 的四个主要接口： Cloneable， 用于对象克隆 Comparable，用于对象比较 Serializeble，用于对象序列化 Runnable，用于对象线程化 创建方式 java.lang.Thread 线程继承Thread类，实现run方法 代码： 123456public class ThreadDemo1 extends Thread { @Override public void run() { System.out.println(\"hello\"); }} java.lang.Runnable接口 线程实现Runnable接口，实现run方法 代码: 123456public class ThreadDemo2 implements Runnable{ @Override public void run() { System.out.println(\"hello\"); }} Thread方式 可以通过继承Thread类来创建线程 通过start方法来启动线程的run方法 代码： 12345678910public class ThreadDemo1 extends Thread { @Override public void run() { System.out.println(\"hello\"); } public static void main(String[] args) { new ThreadDemo1().start(); }} Runable方式： 可以通过实现Runnable接口来创建线程 实现Runnable的对象必须包装在Thread类里面，才可以启动 通过start方法来启动线程的run方法 代码: 12345678910public class ThreadDemo2 implements Runnable{ @Override public void run() { System.out.println(\"hello\"); } public static void main(String[] args) { new Thread(new ThreadDemo2()).start(); }}","link":"/2020/02/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(1)/"},{"title":"Java并发框架Executor","text":"从JDK5开始引入Executor框架，在每次使用new创建线程会导致代价很大，而使用使用框架可以使线程重复利用，程序员无需关心线程池执行任务的过程，只需要吧任务提交即可。 首先需要了解Executor框架中几个比较重要的类和接口 CallableCallable是一个接口，只声明了一个call方法 1234public interface Callable&lt;V&gt; { V call() throws Exception;} Callable和Runable类型，只不过Callable有返回值，返回类型和参数类型一致。 FutureFuture对具体提交的Callable任务执行结果进行取消，查询是否完成，获取结果。可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。 123456789public interface Future&lt;V&gt; { V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); } Future中的五个方法 V get()方法: 获取结果，这个方法会阻塞，直到计算完成 V get(long timeout, TimeUnit unit)方法：获取结果，这个方法会阻塞，直到计算完成或者超过了指定的时间。如果不成功，第二个方法会抛出TimeoutException异常。 boolean cancel(boolean mayInterruptIfRunning)方法：尝试取消这个方法的运行。如果任务已经开始，并且mayInterruptIfRunning参数为true，它就会被中断。如果成功执行了取消操作，则返回true。 boolean isCancelled()方法：如果任务在完成之前被取消，则返回true boolean isDone()方法：如果任务结束，无论是正常完成、中途取消，还是发生异常，则返回true。 ExecutorExecutor是一个接口，它将任务的提交与任务的执行分离开来，定义了一个接收Runnable对象的方法execute。Executor是Executor框架中最基础的一个接口，类似于集合中的Collection接口。 1234public interface Executor { void execute(Runnable command);} ExecutorServiceExecutorService继承了Executor,是线程池服务ExecutorService中的方法： Future submit(Callable task)方法：调用submit时会得到一个Future对象用来得到结果或者取消任务 Future&lt;?&gt; submit(Runnable task)方法：得到Future对象，但是get方法在完成的时候返回指定的result对象 Future submit(Runnable task, T result)方法：得到Future对象，get方法在完成的时候返回指定的result对象 void shutdown()方法 使用完一个线程池时，可以调用，启动线程池的关闭序列。完成已经提交的任务但不在接受新的任务 ExecutorsExecutors类中有许多静态工厂方法，用来构造线程池。Executors.newCachedThreadPool/newFixedThreadPool 创建线程池这两个方法返回的是实现ExecutorService接口的ThreadPoolExecutor newCachedThreadPool方法构造一个线程池是，会立即执行各个任务，空闲进程会保留60秒，如果有空线程可用，就使用空线程执行任务，如果没有，则创建一个。newFixedThreadPool会创建一个固定大小的线程池，空线程会一直保留。如果线程生成周期很短，或者大量时间都在阻塞，应使用newCachedThreadPool创建线程池。如果线程工作量大而且并不阻塞，为了得到最优的运行速度，并发线程数应该等于处理器内核数，应使用newFixedThreadPool 总结使用连接池时所用的工作 调用Executors类中的静态方法 newCachedThreadPool或者newFixedThreadPool 调用submit提交Runnable或者Callable对象 保存好返回的Future对象，以便得到结果或者取消任务 当不想再提交任何任务时，调用shutdown","link":"/2020/02/04/Java%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6Executor/"},{"title":"Tcp 三次握手","text":"TCP采用三次握手来建立一个连接 位码SYN(synchronous建立联机)ACK(acknowledgement 确认)PSH(push传送) FIN(finish结束)RST(reset重置)URG(urgent紧急)Sequence number(顺序号码)Acknowledge number(确认号码) 三次握手的过程第一步 客户端向服务器发送位码为SYN=1，同时随机生成一个Seq number的数据包到服务器。发送完毕后，客户端进入 SYN_SEND 状态。 第二步 服务器收到连接S请求报文段后，向客户端发送位码ACK=1和一个生成的Ack number，Ack number的值为服务器接收到客户端发送的Seq number的值加1，同样服务器需要向发送建立请求，服务器会发送位码为SYN=1，同时随机生成一个Seq number的数据包到客户端。 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三步 客户端收到服务器的Ack number后会检验，即第一次发送的Seq number+1以及ACK位码是否为1，若正确则向服务器发送位码ACK=1和一个Ack number,Ack number的值为从服务器接收到的Seq number的值加1。发送完毕后，客户端进入 ESTABLISHED 状态,服务器收到后检验是否正确，如果正确的话，连接建立成功。当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。","link":"/2020/02/11/Tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"},{"title":"Redis事务","text":"事务的实现一个事务从开始到结束会经历以下三个阶段： 事务开始 命令入队 事务执行 事务在执行期间，服务器不会中断事务而去执行其他客户端的命令请求，它会将事务中的所有命令都执行完，然后才会去执行其他客户端的请求 事务的开始MULTI命令用于开启一个事务 通过在客户端状态的flags属性中的REDIS_MULTI标识完成将非事务状态切换为事务状态 命令的入队当客户端切换到事务状态后，假如客户端发送的是EXEC、DISCARD,、WATCH、MULTI，服务器会立即执行，否则将命令放入事务队列里面，如果入队成功向客户端返回QUEUED，如果有命令入队失败，客户端端会取消这个事务 事务的执行当一个出入事务状态的客户端向服务器发送EXEC命令时，这个EXEC将立刻被服务器执行。服务器会遍历这个客户端的事务队列，执行事务队列保存所有的命令，最后将结果返回给服务器 放弃事务当执行DISCARD 命令时，事务会被放弃，事务队列会被清空，并且客户端会从事务状态中退出 使用check-and-set操作实现乐观锁WATCH命令可以为Redis事务提供check-and-set行为它可以在EXEC命令执行之前，监视任一的数据库键，当使用WATCH操作后会将客户端的标识添加到watched_keys字典中所对应的数据库键的链表中，在数据库键修改时，会遍历链表中的所有客户端，将客户端的REDIS_DIRTY_CAS标识打开，最后在执行EXEC命令时，通过判断REDIS_DIRTY_CAS标识是否打开来决定是否执行事务 Redis事务的ACID性质 原子性 对于Redis事务功能来说，事务队列的命令要么全部执行，要么就一个也不执行 一致性 “一致”指数据符合数据库本身的定义和要求，没有包含非法或无效的错误数据 Redis处理错误的方式： 入队错误 如果一个事务在入队命令的过程中，出现了不存在的命令，或者命令格式不正确的情况，那么 Redis拒绝为这个事务服务 执行错误 比如对数据库键执行了错误类型的操作，出错的命令会被服务器识别出来，并进行相应的处理 服务器停机 隔离性 Redis使用单线程的方式执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断。因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性 耐久性 Redis事务的耐久性由Redis所使用的持久化模式决定 参考资料 http://redisdoc.com/topic/transaction.html# Redis 设计与实现，黄健宏著，机械工业出版社，2019年","link":"/2020/03/16/edis%E4%BA%8B%E5%8A%A1/"},{"title":"Java多线程(二)","text":"一 Java多线程的规则第一条规则：调用run方法，来启动run方法，将会是串行运行 代码： 123456789101112131415161718192021class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().run(); while (true){ System.out.println(\"main thread is running\"); Thread.sleep(10); } }}class TestThread0{ public void run(){ while (true){ System.out.println(\" TestThread1 is running\"); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 12345TestThread1 is runningTestThread1 is runningTestThread1 is runningTestThread1 is runningTestThread1 is running 调用start方法，来启动run方法，将会是并行运行 代码： 123456789101112131415161718192021class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().start(); while (true){ System.out.println(\"main thread is running\"); Thread.sleep(1000); } }}class TestThread0 extends Thread{ public void run(){ while (true){ System.out.println(\" TestThread1 is running\"); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 123456789main thread is running TestThread1 is runningmain thread is running TestThread1 is running TestThread1 is runningmain thread is runningmain thread is running TestThread1 is running TestThread1 is running 第二条规则：main线程可能早于子线程结束 代码： 12345678910111213141516171819class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().start(); System.out.println(\"main thread is end\"); }}class TestThread0 extends Thread{ public void run(){ while (true){ System.out.println(\" TestThread1 is running\"); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 12345678main thread is end TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running 第三条规则： 实现Runnable的对象必须包装在Thread类里面 不能直接对Runnable的对象进行start方法 第四条规则： 实现一个线程对象不能多次start，多次start将报异常 多个线程对象都start后，哪一个先执行，完全由JVM/操作系统来主导，程序员无法指定 代码 12345678910111213141516171819class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); }}class TestThread0 extends Thread{ public void run(){ while (true){ System.out.println(String.format(\"%s is running\",Thread.currentThread().getName())); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 1234567Thread-2 is runningThread-0 is runningThread-1 is runningThread-0 is runningThread-1 is runningThread-2 is runningThread-2 is running Java多线程实现对比 Thread vs Runnable Thread占据了父类名额 Thread类实现Runnable Runnable启动时需要Thread类的支持 Runnable更容易实现多线程中资源共享(Thread里面必须使用static变量，才能实现变量共享)","link":"/2020/02/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C-1/"},{"title":"spring boot中使用JSR-303","text":"概述JSR 303（Bean验证）是用于Java EE和Java SE中JavaBean验证的Java API规范。简而言之，它提供了一种简单的方法来确保JavaBean的属性中具有正确的值。 添加Meven依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 在需要校验的参数实体前添加@Valid注解代码: 1234567891011public String doLogin(@Valid User user){ Map&lt;String,Object&gt; vo = userService.login(user) ; JSONObject jsonObject =new JSONObject(); if(vo.get(\"msg\")!=null){ jsonObject.put(\"msg\",vo.get(\"msg\")); jsonObject.put(\"code\",999); }else { jsonObject.put(\"code\",0); } return jsonObject.toJSONString(); } 在需要进行校验的参数上添加注解代码: 1234567891011public class User { @NotNull @IsMobile private String mobile; @NotNull private String password; } - 常用注解 constraint 详细信息 @Null 被注释的元素必须为null @NOtNull 被注释的元素必须不为null @AssertTrue 被注释的元素必须为True @AssertFalse 被注释的元素必须为False - 使用自定义注解 1234567891011121314@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint( validatedBy = {IsMobileValidator.class})public @interface IsMobile { String message() default \"手机号码格式错误\"; Class&lt;?&gt;[] groups() default {}; Class&lt;? extends Payload&gt;[] payload() default {};} 在自定义注解中有以下三个方法必须需要定义 ==message()== 方法用于定义校验参数错误时，应该输出的消息 ==groups()== 方法该方法指定与约束声明关联的处理组，默认值必须是一个空的数组，通常用于控制评估约束的顺序，或用于验证JavaBean的部分状态。 ==groups()== 方法该方法指定与约束声明关联的有效负载，默认值必须是一个空的数组 validatedBy里面的参数指定了这个注解真正的验证者类 IsMobileValidator.class 12345678910111213public class IsMobileValidator implements ConstraintValidator&lt;IsMobile, String&gt;{ @Override public void initialize(IsMobile constraintAnnotation) { } @Override public boolean isValid(String value, ConstraintValidatorContext constraintValidatorContext) { return ValidatorUtil.isMobile(value); }} 该类需要实现==ConstraintValidator==接口，该接口用泛型指定两个参数，第一个参数就是自定义注解的类，第二个参数就是具体需要校验的值的类型 ==initialize()== 方法该方法用于初始化 ==isValid()== 方法该方法用于判断合法 测试当使用错误的格式时，可以看到以上结果 使用统一异常处理来修改返回格式1234567891011121314151617181920@ControllerAdvicepublic class globalExceptionHandler { @ResponseBody @ExceptionHandler(value = Exception.class) public String errorHandler(Exception e) { JSONObject jsonObject = new JSONObject(); if(e instanceof BindException){ BindException ex = (BindException)e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); ObjectError error = errors.get(0); String msg = error.getDefaultMessage(); jsonObject.put(\"msg\",msg); } return jsonObject.toJSONString(); }} 运行结果","link":"/2020/02/14/spring-boot%E4%B8%AD%E4%BD%BF%E7%94%A8JSR-303/"}],"tags":[{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"事务","slug":"事务","link":"/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"}],"categories":[]}