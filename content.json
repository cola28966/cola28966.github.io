{"pages":[{"title":"tags","text":"多线程","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Java多线程(一)","text":"一 进程和线程的定义和区别进程： 每个独立执行的任务就是一个进程线程：一个程序可以包括多个子任务，可窜/并行，每个子任务可以称为一个线程，线程是进程的一部分。 多线程vs多进程 线程数据共享 线程通讯更高效 线程更清量级，更容易切换 多个线程更容易管理 二 多线程的创建Java 的四个主要接口： Cloneable， 用于对象克隆 Comparable，用于对象比较 Serializeble，用于对象序列化 Runnable，用于对象线程化 创建方式 java.lang.Thread 线程继承Thread类，实现run方法 代码： 123456public class ThreadDemo1 extends Thread { @Override public void run() { System.out.println(\"hello\"); }} java.lang.Runnable接口 线程实现Runnable接口，实现run方法 代码: 123456public class ThreadDemo2 implements Runnable{ @Override public void run() { System.out.println(\"hello\"); }} Thread方式 可以通过继承Thread类来创建线程 通过start方法来启动线程的run方法 代码： 12345678910public class ThreadDemo1 extends Thread { @Override public void run() { System.out.println(\"hello\"); } public static void main(String[] args) { new ThreadDemo1().start(); }} Runable方式： 可以通过实现Runnable接口来创建线程 实现Runnable的对象必须包装在Thread类里面，才可以启动 通过start方法来启动线程的run方法 代码: 12345678910public class ThreadDemo2 implements Runnable{ @Override public void run() { System.out.println(\"hello\"); } public static void main(String[] args) { new Thread(new ThreadDemo2()).start(); }}","link":"/2020/02/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(1)/"},{"title":"Java多线程(二)","text":"一 Java多线程的规则第一条规则：调用run方法，来启动run方法，将会是串行运行 代码： 123456789101112131415161718192021class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().run(); while (true){ System.out.println(\"main thread is running\"); Thread.sleep(10); } }}class TestThread0{ public void run(){ while (true){ System.out.println(\" TestThread1 is running\"); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 12345TestThread1 is runningTestThread1 is runningTestThread1 is runningTestThread1 is runningTestThread1 is running 调用start方法，来启动run方法，将会是并行运行 代码： 123456789101112131415161718192021class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().start(); while (true){ System.out.println(\"main thread is running\"); Thread.sleep(1000); } }}class TestThread0 extends Thread{ public void run(){ while (true){ System.out.println(\" TestThread1 is running\"); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 123456789main thread is running TestThread1 is runningmain thread is running TestThread1 is running TestThread1 is runningmain thread is runningmain thread is running TestThread1 is running TestThread1 is running 第二条规则：main线程可能早于子线程结束 代码： 12345678910111213141516171819class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().start(); System.out.println(\"main thread is end\"); }}class TestThread0 extends Thread{ public void run(){ while (true){ System.out.println(\" TestThread1 is running\"); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 12345678main thread is end TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running 第三条规则： 实现Runnable的对象必须包装在Thread类里面 不能直接对Runnable的对象进行start方法 第四条规则： 实现一个线程对象不能多次start，多次start将报异常 多个线程对象都start后，哪一个先执行，完全由JVM/操作系统来主导，程序员无法指定 代码 12345678910111213141516171819class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); }}class TestThread0 extends Thread{ public void run(){ while (true){ System.out.println(String.format(\"%s is running\",Thread.currentThread().getName())); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 1234567Thread-2 is runningThread-0 is runningThread-1 is runningThread-0 is runningThread-1 is runningThread-2 is runningThread-2 is running Java多线程实现对比 Thread vs Runnable Thread占据了父类名额 Thread类实现Runnable Runnable启动时需要Thread类的支持 Runnable更容易实现多线程中资源共享(Thread里面必须使用static变量，才能实现变量共享)","link":"/2020/02/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C-1/"},{"title":"Java多线程(三）","text":"一 Java多线程信息共享1 实现信息共享的方式通过共享变量在多个线程中共享消息 static变量，对应继承Thread类的线程只能通过这种方式 同一个Runnable类的成员变量 2 多线程信息共享问题Java内存模型中的内存结构Java内存模型将内存分为共享内存和本地内存。共享内存又称为堆内存，指的就是线程之间共享的内存，包含所有的实列域、静态域和数组元素。每一个线程都有一个私有的，只对自己可见的内存，称之为本地内存。线程并不直接使用共享内存，而是会在本地内存中存储一个共享内存的副本，使用这个副本参与运算。由于这个副本的参与，导致了线程之间对共享内存的读写存在可见性问题。 可见性 可见性是指，当一个线程对共享变量进行了修改，那么其他线程可以立刻看到修改后的最新值。Java多线程环境下，线程首次读取要操作的变量时，是先到主内存中获取该变量，然后将其放入工作内存，以后关于该变量的操作都是在以工作内存中的变量值为基准的。之后如果要修改该变量的值，也是直接修改工作内存中的变量，最后会在某一时刻将工作内存中该变量的值刷新同步回主内存，之后其他线程就能感知到该变量的变化，实现可见性了！ 只是什么时候将工作内存中的值同步会主内存，这个时间点在自然情况下是不确定的，所以假设线程A修改了变量的值之后，在正式将其同步会主内存之前，线程B获取了主内存中变量的原先值，而过了一会后线程A刷新了主内存，但是此时主内存中的变量值与线程B工作内存中的变量值已经不一致了，这个时候就出现不可见的问题了。volatile来声明变量或者用锁来保护起来 原子性 所谓原子性是指在一个操作或多次操作中，要么所有的操作全部都得到执行，要么所有的操作都不执行。 i++，并非原子性操作 1 主存i到工作缓存(副本)中 2 个CPU执行副本i+1操作 3 CPU将结果写入副本中 4 数据从副本刷到主存中 volatile Java语言提供了一种稍弱的同步机制，即volatile类型，用来确保将变量的更新操作通知到其他线程。使用就是在变量前面加上volatile即可。在 JMM 中，线程之间的通信采用共享内存来实现的。volatile 的内存语义是： 当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值，立即刷新到主内存中。 当读一个 volatile 变量时，JMM 会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量。 对于volatile只能保证可见性不能确保原子性对于++i说当线程A执行完第二步，此时线程B更改了变量i的值，虽然此时线程A知道变量i发生了变化，但是由于操作已经执行完，所以还是只能执行第3步把变量i的值覆盖回主内存，从而又造成了错误数据。 synchronized 对于保证原子性操作可以使用synchronized来实现某一个线程运行一个代码块，其他线程不能运行这个代码块","link":"/2020/02/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89%EF%BC%89/"},{"title":"spring boot中使用JSR-303","text":"概述JSR 303（Bean验证）是用于Java EE和Java SE中JavaBean验证的Java API规范。简而言之，它提供了一种简单的方法来确保JavaBean的属性中具有正确的值。 添加Meven依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 在需要校验的参数实体前添加@Valid注解代码: 1234567891011public String doLogin(@Valid User user){ Map&lt;String,Object&gt; vo = userService.login(user) ; JSONObject jsonObject =new JSONObject(); if(vo.get(\"msg\")!=null){ jsonObject.put(\"msg\",vo.get(\"msg\")); jsonObject.put(\"code\",999); }else { jsonObject.put(\"code\",0); } return jsonObject.toJSONString(); } 在需要进行校验的参数上添加注解代码: 1234567891011public class User { @NotNull @IsMobile private String mobile; @NotNull private String password; } - 常用注解 constraint 详细信息 @Null 被注释的元素必须为null @NOtNull 被注释的元素必须不为null @AssertTrue 被注释的元素必须为True @AssertFalse 被注释的元素必须为False - 使用自定义注解 1234567891011121314@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint( validatedBy = {IsMobileValidator.class})public @interface IsMobile { String message() default \"手机号码格式错误\"; Class&lt;?&gt;[] groups() default {}; Class&lt;? extends Payload&gt;[] payload() default {};} 在自定义注解中有以下三个方法必须需要定义 ==message()== 方法用于定义校验参数错误时，应该输出的消息 ==groups()== 方法该方法指定与约束声明关联的处理组，默认值必须是一个空的数组，通常用于控制评估约束的顺序，或用于验证JavaBean的部分状态。 ==groups()== 方法该方法指定与约束声明关联的有效负载，默认值必须是一个空的数组 validatedBy里面的参数指定了这个注解真正的验证者类 IsMobileValidator.class 12345678910111213public class IsMobileValidator implements ConstraintValidator&lt;IsMobile, String&gt;{ @Override public void initialize(IsMobile constraintAnnotation) { } @Override public boolean isValid(String value, ConstraintValidatorContext constraintValidatorContext) { return ValidatorUtil.isMobile(value); }} 该类需要实现==ConstraintValidator==接口，该接口用泛型指定两个参数，第一个参数就是自定义注解的类，第二个参数就是具体需要校验的值的类型 ==initialize()== 方法该方法用于初始化 ==isValid()== 方法该方法用于判断合法 测试当使用错误的格式时，可以看到以上结果 使用统一异常处理来修改返回格式1234567891011121314151617181920@ControllerAdvicepublic class globalExceptionHandler { @ResponseBody @ExceptionHandler(value = Exception.class) public String errorHandler(Exception e) { JSONObject jsonObject = new JSONObject(); if(e instanceof BindException){ BindException ex = (BindException)e; List&lt;ObjectError&gt; errors = ex.getAllErrors(); ObjectError error = errors.get(0); String msg = error.getDefaultMessage(); jsonObject.put(\"msg\",msg); } return jsonObject.toJSONString(); }} 运行结果","link":"/2020/02/14/spring-boot%E4%B8%AD%E4%BD%BF%E7%94%A8JSR-303/"},{"title":"Tcp 三次握手","text":"TCP采用三次握手来建立一个连接 位码SYN(synchronous建立联机)ACK(acknowledgement 确认)PSH(push传送) FIN(finish结束)RST(reset重置)URG(urgent紧急)Sequence number(顺序号码)Acknowledge number(确认号码) 三次握手的过程第一步 客户端向服务器发送位码为SYN=1，同时随机生成一个Seq number的数据包到服务器。发送完毕后，客户端进入 SYN_SEND 状态。 第二步 服务器收到连接S请求报文段后，向客户端发送位码ACK=1和一个生成的Ack number，Ack number的值为服务器接收到客户端发送的Seq number的值加1，同样服务器需要向发送建立请求，服务器会发送位码为SYN=1，同时随机生成一个Seq number的数据包到客户端。 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三步 客户端收到服务器的Ack number后会检验，即第一次发送的Seq number+1以及ACK位码是否为1，若正确则向服务器发送位码ACK=1和一个Ack number,Ack number的值为从服务器接收到的Seq number的值加1。发送完毕后，客户端进入 ESTABLISHED 状态,服务器收到后检验是否正确，如果正确的话，连接建立成功。当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。","link":"/2020/02/11/Tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"},{"title":"Java并发框架Executor","text":"从JDK5开始引入Executor框架，在每次使用new创建线程会导致代价很大，而使用使用框架可以使线程重复利用，程序员无需关心线程池执行任务的过程，只需要吧任务提交即可。 首先需要了解Executor框架中几个比较重要的类和接口 CallableCallable是一个接口，只声明了一个call方法 1234public interface Callable&lt;V&gt; { V call() throws Exception;} Callable和Runable类型，只不过Callable有返回值，返回类型和参数类型一致。 FutureFuture对具体提交的Callable任务执行结果进行取消，查询是否完成，获取结果。可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。 123456789public interface Future&lt;V&gt; { V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); } Future中的五个方法 V get()方法: 获取结果，这个方法会阻塞，直到计算完成 V get(long timeout, TimeUnit unit)方法：获取结果，这个方法会阻塞，直到计算完成或者超过了指定的时间。如果不成功，第二个方法会抛出TimeoutException异常。 boolean cancel(boolean mayInterruptIfRunning)方法：尝试取消这个方法的运行。如果任务已经开始，并且mayInterruptIfRunning参数为true，它就会被中断。如果成功执行了取消操作，则返回true。 boolean isCancelled()方法：如果任务在完成之前被取消，则返回true boolean isDone()方法：如果任务结束，无论是正常完成、中途取消，还是发生异常，则返回true。 ExecutorExecutor是一个接口，它将任务的提交与任务的执行分离开来，定义了一个接收Runnable对象的方法execute。Executor是Executor框架中最基础的一个接口，类似于集合中的Collection接口。 1234public interface Executor { void execute(Runnable command);} ExecutorServiceExecutorService继承了Executor,是线程池服务ExecutorService中的方法： Future submit(Callable task)方法：调用submit时会得到一个Future对象用来得到结果或者取消任务 Future&lt;?&gt; submit(Runnable task)方法：得到Future对象，但是get方法在完成的时候返回指定的result对象 Future submit(Runnable task, T result)方法：得到Future对象，get方法在完成的时候返回指定的result对象 void shutdown()方法 使用完一个线程池时，可以调用，启动线程池的关闭序列。完成已经提交的任务但不在接受新的任务 ExecutorsExecutors类中有许多静态工厂方法，用来构造线程池。Executors.newCachedThreadPool/newFixedThreadPool 创建线程池这两个方法返回的是实现ExecutorService接口的ThreadPoolExecutor newCachedThreadPool方法构造一个线程池是，会立即执行各个任务，空闲进程会保留60秒，如果有空线程可用，就使用空线程执行任务，如果没有，则创建一个。newFixedThreadPool会创建一个固定大小的线程池，空线程会一直保留。如果线程生成周期很短，或者大量时间都在阻塞，应使用newCachedThreadPool创建线程池。如果线程工作量大而且并不阻塞，为了得到最优的运行速度，并发线程数应该等于处理器内核数，应使用newFixedThreadPool 总结使用连接池时所用的工作 调用Executors类中的静态方法 newCachedThreadPool或者newFixedThreadPool 调用submit提交Runnable或者Callable对象 保存好返回的Future对象，以便得到结果或者取消任务 当不想再提交任何任务时，调用shutdown","link":"/2020/02/04/Java%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6Executor/"}],"tags":[{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"}],"categories":[]}