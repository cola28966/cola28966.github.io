{"pages":[{"title":"tags","text":"多线程","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Java多线程(三）","text":"一 Java多线程信息共享1 实现信息共享的方式通过共享变量在多个线程中共享消息 static变量，对应继承Thread类的线程只能通过这种方式 同一个Runnable类的成员变量 2 多线程信息共享问题Java内存模型中的内存结构Java内存模型将内存分为共享内存和本地内存。共享内存又称为堆内存，指的就是线程之间共享的内存，包含所有的实列域、静态域和数组元素。每一个线程都有一个私有的，只对自己可见的内存，称之为本地内存。线程并不直接使用共享内存，而是会在本地内存中存储一个共享内存的副本，使用这个副本参与运算。由于这个副本的参与，导致了线程之间对共享内存的读写存在可见性问题。 可见性 可见性是指，当一个线程对共享变量进行了修改，那么其他线程可以立刻看到修改后的最新值。Java多线程环境下，线程首次读取要操作的变量时，是先到主内存中获取该变量，然后将其放入工作内存，以后关于该变量的操作都是在以工作内存中的变量值为基准的。之后如果要修改该变量的值，也是直接修改工作内存中的变量，最后会在某一时刻将工作内存中该变量的值刷新同步回主内存，之后其他线程就能感知到该变量的变化，实现可见性了！ 只是什么时候将工作内存中的值同步会主内存，这个时间点在自然情况下是不确定的，所以假设线程A修改了变量的值之后，在正式将其同步会主内存之前，线程B获取了主内存中变量的原先值，而过了一会后线程A刷新了主内存，但是此时主内存中的变量值与线程B工作内存中的变量值已经不一致了，这个时候就出现不可见的问题了。volatile来声明变量或者用锁来保护起来 原子性 所谓原子性是指在一个操作或多次操作中，要么所有的操作全部都得到执行，要么所有的操作都不执行。 i++，并非原子性操作 1 主存i到工作缓存(副本)中 2 个CPU执行副本i+1操作 3 CPU将结果写入副本中 4 数据从副本刷到主存中 volatile Java语言提供了一种稍弱的同步机制，即volatile类型，用来确保将变量的更新操作通知到其他线程。使用就是在变量前面加上volatile即可。在 JMM 中，线程之间的通信采用共享内存来实现的。volatile 的内存语义是： 当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值，立即刷新到主内存中。 当读一个 volatile 变量时，JMM 会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量。 对于volatile只能保证可见性不能确保原子性对于++i说当线程A执行完第二步，此时线程B更改了变量i的值，虽然此时线程A知道变量i发生了变化，但是由于操作已经执行完，所以还是只能执行第3步把变量i的值覆盖回主内存，从而又造成了错误数据。 synchronized 对于保证原子性操作可以使用synchronized来实现某一个线程运行一个代码块，其他线程不能运行这个代码块","link":"/2020/02/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89%EF%BC%89/"},{"title":"Java多线程(一)","text":"一 进程和线程的定义和区别进程： 每个独立执行的任务就是一个进程线程：一个程序可以包括多个子任务，可窜/并行，每个子任务可以称为一个线程，线程是进程的一部分。 多线程vs多进程 线程数据共享 线程通讯更高效 线程更清量级，更容易切换 多个线程更容易管理 二 多线程的创建Java 的四个主要接口： Cloneable， 用于对象克隆 Comparable，用于对象比较 Serializeble，用于对象序列化 Runnable，用于对象线程化 创建方式 java.lang.Thread 线程继承Thread类，实现run方法 代码： 123456public class ThreadDemo1 extends Thread { @Override public void run() { System.out.println(\"hello\"); }} java.lang.Runnable接口 线程实现Runnable接口，实现run方法 代码: 123456public class ThreadDemo2 implements Runnable{ @Override public void run() { System.out.println(\"hello\"); }} Thread方式 可以通过继承Thread类来创建线程 通过start方法来启动线程的run方法 代码： 12345678910public class ThreadDemo1 extends Thread { @Override public void run() { System.out.println(\"hello\"); } public static void main(String[] args) { new ThreadDemo1().start(); }} Runable方式： 可以通过实现Runnable接口来创建线程 实现Runnable的对象必须包装在Thread类里面，才可以启动 通过start方法来启动线程的run方法 代码: 12345678910public class ThreadDemo2 implements Runnable{ @Override public void run() { System.out.println(\"hello\"); } public static void main(String[] args) { new Thread(new ThreadDemo2()).start(); }}","link":"/2020/02/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(1)/"},{"title":"Java多线程(二)","text":"一 Java多线程的规则第一条规则：调用run方法，来启动run方法，将会是串行运行 代码： 123456789101112131415161718192021class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().run(); while (true){ System.out.println(\"main thread is running\"); Thread.sleep(10); } }}class TestThread0{ public void run(){ while (true){ System.out.println(\" TestThread1 is running\"); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 12345TestThread1 is runningTestThread1 is runningTestThread1 is runningTestThread1 is runningTestThread1 is running 调用start方法，来启动run方法，将会是并行运行 代码： 123456789101112131415161718192021class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().start(); while (true){ System.out.println(\"main thread is running\"); Thread.sleep(1000); } }}class TestThread0 extends Thread{ public void run(){ while (true){ System.out.println(\" TestThread1 is running\"); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 123456789main thread is running TestThread1 is runningmain thread is running TestThread1 is running TestThread1 is runningmain thread is runningmain thread is running TestThread1 is running TestThread1 is running 第二条规则：main线程可能早于子线程结束 代码： 12345678910111213141516171819class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().start(); System.out.println(\"main thread is end\"); }}class TestThread0 extends Thread{ public void run(){ while (true){ System.out.println(\" TestThread1 is running\"); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 12345678main thread is end TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running TestThread1 is running 第三条规则： 实现Runnable的对象必须包装在Thread类里面 不能直接对Runnable的对象进行start方法 第四条规则： 实现一个线程对象不能多次start，多次start将报异常 多个线程对象都start后，哪一个先执行，完全由JVM/操作系统来主导，程序员无法指定 代码 12345678910111213141516171819class ThreadDemo3{ public static void main(String[] args) throws Exception{ new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); }}class TestThread0 extends Thread{ public void run(){ while (true){ System.out.println(String.format(\"%s is running\",Thread.currentThread().getName())); try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } }} 运行结果 1234567Thread-2 is runningThread-0 is runningThread-1 is runningThread-0 is runningThread-1 is runningThread-2 is runningThread-2 is running Java多线程实现对比 Thread vs Runnable Thread占据了父类名额 Thread类实现Runnable Runnable启动时需要Thread类的支持 Runnable更容易实现多线程中资源共享(Thread里面必须使用static变量，才能实现变量共享)","link":"/2020/02/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C-1/"}],"tags":[{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"categories":[]}